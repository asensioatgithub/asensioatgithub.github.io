<!DOCTYPE html>
<html lang="en">

<!-- layout.ejs-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="Asensio">
    <meta name="keyword" content="hexo, hexo theme, A-RSnippet, responsive, bootstrap">
    <link rel="canonical" href="http://yoursite.com/Socket编程/">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="A-RSnippet&lt;br&gt;&lt;a href=&#34;https://github.com/huyingjie/hexo-theme-A-RSnippet&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Release-v0.1.0-red.svg&#34;&gt;&lt;/a&gt;" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

    <title>
        
        Socket编程｜Asensio&#39;s Blog
        
    </title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <link rel="stylesheet" href="/css/main.css">

    
      <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
      <link rel="stylesheet" href="/css/highlight.css">
    

    
      <script id="dsq-count-scr" src="//hexo-a-rsnippet.disqus.com/count.js" async></script>
    


    

    

    


    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    




    <script async defer src="https://buttons.github.io/buttons.js"></script>

    <!-- user customization -->
    <link rel="stylesheet" href="/css/arsnippet.css">
    <script src="/js/arsnippet.css.js"></script>
</head>

<style>
    header.intro-header {
        background-image: url('')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<header>
<!--
  <nav class="navbar navbar-default header-navbar" id="nav-top" data-ispost = "true" data-istags="false" data-ishome = "false" >
    <div class="container-fluid">
      <div class="navbar-header page-scroll">
        <button type="button" class="navbar-toggle" data-toggle="collapse" aria-expanded="false"  data-target="#website_navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <span class="navbar-brand animated pulse">
          <a class="brand-logo" href="/">
            A-RSnippet<br><a href="https://github.com/huyingjie/hexo-theme-A-RSnippet" target="_blank"><img src="https://img.shields.io/badge/Release-v0.1.0-red.svg"></a>
          </a>
        </span>
      </div>

      <div class="collapse navbar-collapse" id="website_navbar">
          <ul class="nav navbar-nav navbar-right">
              
                <li>
                  <a href="/">home</a>
                </li>
              
                <li>
                  <a href="/tutorial/">Tutorial</a>
                </li>
              
                <li>
                  <a href="/archives/">archives</a>
                </li>
              
                <li>
                  <a href="/categories/">categories</a>
                </li>
              
                <li>
                  <a href="/tags/">tags</a>
                </li>
              
          </ul>
      </div>
  </nav>
-->

  
    <style>
       .intro-header {
          background-image: url('/img/default_bg.png')          
      }
    </style>

    <div class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                    <div class="site-heading">
                        <a href="/" style="color:white"><h1>Asensio&#39;s Blog</h1></a>
                        <div class="post-subtitle"></div>
                        
                          <span class="meta">
                               <span class="meta-item">Author: Asensio</span>
                               <span class="meta-item">Date: Oct 16, 2017</span>
                               
                                 <span class="meta-item">Updated On: May 2, 2018</span>
                               
                          </span>
                          <div class="tags text-center">
                              Categories: 
                              <a class="tag" href="/categories/#网络编程"
                                 title="网络编程">网络编程</a>
                              
                          </div>
                          <div class="tags text-center">
                              Tags: 
                              <a class="tag" href="/tags/#Socket"
                                 title="Socket">Socket</a>
                              
                          </div>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
  
</header>


<!-- Main Content -->
<!-- post.ejs -->
<article>
    <div class="container">
      <div class="col-lg-8 col-lg-offset-1 col-sm-9">
          
            <div class="text-center"><div class="addthis_inline_share_toolbox">
  <script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5272bc2a7b3c1ddc" async = "async" ></script>
</div>
</div><hr>
          
          <!---->
	 <div style="font-size:18px" class="subscribe">Socket编程</div><p>
          <p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）．<br>     说白了Socket是应用层与TCP/IP协议族通信的中间软件抽象层，<strong>它是一组接口</strong>。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。<br><a id="more"></a><br>      同一台主机不同进程可以用进程号来唯一标识，但是在网络环境下进程号并不能唯一标识该进程。TCP/IP主要引入了网络地址、端口和连接等概念来解决网络间进程标识问题。套接字（Socket）是一个指向传输提供者的句柄，TCP/IP协议支持3种类型的套接字，分别是流式套接字、数据报式套接字和原始套接字。</p>
<h1 id="Socket类型"><a href="#Socket类型" class="headerlink" title="Socket类型"></a>Socket类型</h1><h2 id="Stream-Socket"><a href="#Stream-Socket" class="headerlink" title="Stream Socket"></a>Stream Socket</h2><p>数据流式是一种面向连接的Socket，针对于面向连接的TCP服务应用，使用使用比较高质量的TCP协议。</p>
<h2 id="Datagram-Socket"><a href="#Datagram-Socket" class="headerlink" title="Datagram Socket"></a>Datagram Socket</h2><p> 数据报式Socket是一种无连接的套接字，对应于无连接的UDP服务应用，相应协议是UDP。</p>
<h2 id="Raw-Socket"><a href="#Raw-Socket" class="headerlink" title="Raw Socket"></a>Raw Socket</h2><p> 除了上面两种常用的套接字类型外，还有一类原始套接字（raw socket），在某些网络应用中担任重要角色。比如我们平时想看一看网络是否通达，就用ping命令测试一下。Ping命令用的是ICMP协议，因此我们不能通过建立一个SOCK_STREAM或SOCK_DGRAM来发送这个包，而只能自己亲自来构建ICMP包来发送。另外一种情况是，许多操作系统只实现了几种常用的协议，而没有实现其它如OSPE、GGP等协议。如果自己有必要编写位于其上的应用，就必须借助raw socket来实现，这是因为操作系统遇到自己不能够处理的数据包，就将这个包交给raw socket处理。<br>Raw socket的作用主要在三个方面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1） 通过raw socket来接收和发送ICMP协议包。</span><br><span class="line">（2） 接收发向本机的但TCP/IP栈不能够处理的IP包。</span><br><span class="line">（3） 用来发送一些自己指定源地址特殊作用的IP包。</span><br></pre></td></tr></table></figure></p>
<h1 id="Socket接口函数"><a href="#Socket接口函数" class="headerlink" title="Socket接口函数"></a>Socket接口函数</h1><h2 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">socket</span><span class="params">(<span class="keyword">int</span> protofamily, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;<span class="comment">//返回sockfd</span></span><br></pre></td></tr></table></figure>
<p>若无错误发生,socket()返回引用套接口的描述字(套接口号)。<br>否则的话,返回SOCKET_ERROR错误,即-1。</p>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。<br>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：<br><strong>1.protofamily</strong>：<br>协议族（family）。常用的协议族有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AF_INET	ipv4网络通信</span><br><span class="line">AF_INET6	ipv6网络通信</span><br><span class="line">AF_LOCAL或称AF_UNIX	本地通信</span><br><span class="line">AF_PACKET	链路层通信</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。在Linux系统中AF_<em>和PF_</em>是等价的。</p>
<p><strong>2.type</strong>：<br>指定socket类型。常用的socket类型有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SOCK_STREAM	流式套接字tcp</span><br><span class="line">SOCK_DGRAM	　数据报式套接字udp</span><br><span class="line">SOCK_RAW	 原始套接字</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p><strong>3.protocol</strong>：故名思意，就是指定协议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IPPROTO_TCP</span><br><span class="line">IPPTOTO_UDP</span><br><span class="line">IPPROTO_ICMP</span><br><span class="line">IPPROTO_IGMP</span><br><span class="line">0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>如ICMP、IGMP、IP等协议，只需要把相应的参数改为IPPROTO_ICM、IPPROTO_ IGMP、IPPROTO_IP就可以了。<br><strong>注意：</strong>并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">socket(AF_INET, SOCK_RAW, IPPROTO_ICMP):</span><br><span class="line">不用构建IP头部分，只发送ICMP头和数据。返回包括IP头和ICMP头和数据。</span><br><span class="line">       raw udp socket(IPPROTO_UDP):</span><br><span class="line">            不用构建IP头部分，只发送UDP头和数据。返回包括IP头和UDP头和数据。</span><br><span class="line">       raw tcp socket(IPPROTO_TCP):</span><br><span class="line">            不用构建IP头部分，只发送TCP头和数据。返回包括IP头和TCP头和数据。</span><br><span class="line">       raw raw socket(IPPROTO_RAW):</span><br><span class="line">            要构建IP头部和要发送的各种协议的头部和数据。返回包括IP头和相应的协议头和数据。</span><br></pre></td></tr></table></figure>
<h2 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind()函数"></a>bind()函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	SOCKET s,	<span class="comment">//待捆绑Socket</span></span></span></span><br><span class="line"><span class="function"><span class="params">	struct sockaddr far * name,	 <span class="comment">//赋予Socket的主机地址标识</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> len	<span class="comment">// name的长度，可用sizeof()获得</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>将IP地址和端口号与所创建的Socket号联系起来。调用成功,返回0。</p>
<h3 id="主机地址标识"><a href="#主机地址标识" class="headerlink" title="主机地址标识"></a>主机地址标识</h3><p>网络环境中的唯一通信端点标识。<br>包含:协议族、IP地址、端口。(俗称三元组)</p>
<p>关于端口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在TCP/IP中,TCP与 UDP使用彼此独立的 端口;</span><br><span class="line">端口大小:16bit(共2 16 个)</span><br><span class="line">端口分为:</span><br><span class="line">1系统全局端口:1~1023;例,HTTP为TCP/80,FTP为TCP/21、UDP/69,SMTP为TCP/25</span><br><span class="line">2系统自动分配端口:1024~5000;</span><br><span class="line">3自由端口:5000~65535;</span><br></pre></td></tr></table></figure></p>
<h3 id="主机地址标识的数据结构"><a href="#主机地址标识的数据结构" class="headerlink" title="主机地址标识的数据结构"></a>主机地址标识的数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span><span class="comment">//共16个字节</span></span><br><span class="line">	u_short sa_family;	<span class="comment">//协议族</span></span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>];	<span class="comment">//主机地址标识(端口号、IP地址)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span><span class="comment">//共16个字节</span></span><br><span class="line">	<span class="keyword">short</span>	sin_family;	<span class="comment">//协议族</span></span><br><span class="line">	u_short sin_port;	<span class="comment">//16bit端口号,网络字节顺序</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">//32bit的IP地址,网络字节顺序</span></span><br><span class="line">	<span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">//未用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置主机地址</span></span><br><span class="line"><span class="comment">//------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetSockAddr</span><span class="params">(struct sockaddr_in *A,WORD Port,<span class="keyword">char</span> *IP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A-&gt;sin_family= AF_INET;<span class="comment">//TCP/IP协议</span></span><br><span class="line">	A-&gt;sin_port= htons(Port);<span class="comment">//端口号。</span></span><br><span class="line">	A-&gt;sin_addr.s_addr= inet_addr(IP); <span class="comment">//IP地址。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">htons():把16 bit的数字从主机字节顺序转换到网络字节顺序</span></span><br><span class="line"><span class="comment">inet_addr():把一个IP地址格式"A.B.C.D"转换成32 bit的网络字节顺序</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>其中:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">	u_long s_addr;<span class="comment">//32bit的IP地址,网络字节顺序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>注：</strong><br>网络字节顺序:16 bit/32 bit整数存放格式––高字节在前,低字节在后。<br>Intel CPU的主机字节顺序: 16 bit/32 bit整数存放格式––低字节在前,高字节在后。</p>
<h2 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen()函数"></a>listen()函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure>
<p>告知内核在sockfd这个描述符上监听是否有连接到来，并设置同时能完成的最大连接数为backlog。3.6节还会继续解释这个参数。当调用listen后，内核就会建立两个队列，一个SYN队列，表示接受到请求，但未完成三次握手的连接；另一个是ACCEPT队列，表示已经完成了三次握手的队列<br><strong>sockfd</strong>是调用socket()函数创建的socket描述符<br><strong>backlog</strong>已经完成三次握手而等待accept的连接数</p>
<h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect()函数"></a>connect()函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这三个参数和bind的三个参数类型一直，<strong>只不过此处strcut sockaddr表示对端公开的地址。</strong>三个参数都是传入参数。<strong>connect顾名思义就是拿来建立连接的函数，只有像tcp这样面向连接、提供可靠服务的协议才需要建立连接</strong></p>
<h2 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h2><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端调用connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
<p><strong>注意：</strong>accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<h2 id="listen、connect、accept流程及三次握手"><a href="#listen、connect、accept流程及三次握手" class="headerlink" title="listen、connect、accept流程及三次握手"></a>listen、connect、accept流程及三次握手</h2><p>以AF_INET,SOCK_STREAM,IPPROTO_TCP三个参数实例化的socket为例:<br><img src="/images/socket_connect.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.服务器端在调用listen之后，内核会建立两个队列，SYN队列和ACCEPT队列，其中ACCPET队列的长度由backlog指定。</span><br><span class="line">2.服务器端在调用accpet之后，将阻塞，等待ACCPT队列有元素。</span><br><span class="line">3.客户端在调用connect之后，将开始发起SYN请求，请求与服务器建立连接，此时称为第一次握手。</span><br><span class="line">4.服务器端在接受到SYN请求之后，把请求方放入SYN队列中，并给客户端回复一个确认帧ACK，此帧还会携带一个请求与客户端建立连接的请求标志，也就是SYN，这称为第二次握手</span><br><span class="line">5.客户端收到SYN+ACK帧后，connect返回，并发送确认建立连接帧ACK给服务器端。这称为第三次握手</span><br><span class="line">6.服务器端收到ACK帧后，会把请求方从SYN队列中移出，放至ACCEPT队列中，而accept函数也等到了自己的资源，从阻塞中唤醒，从ACCEPT队列中取出请求方，重新建立一个新的sockfd，并返回。</span><br></pre></td></tr></table></figure></p>
<p><strong>客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。</strong></p>
<h2 id="send-recv和sendto-recvfrom"><a href="#send-recv和sendto-recvfrom" class="headerlink" title="send/recv和sendto/recvfrom"></a>send/recv和sendto/recvfrom</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="comment">//向一指定目的地发送数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">	SOCKET s,<span class="comment">//源套接口</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> *buf,<span class="comment">//待发送数据的缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> buflen,<span class="comment">//缓冲区中数据的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> flags,<span class="comment">//调用方式标志位,一般取0</span></span></span></span><br><span class="line"><span class="function"><span class="params">	struct sockaddr FAR *to,<span class="comment">//指向目的套接口的主机地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> tolen<span class="comment">//目的套接口主机地址的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="comment">//从一个套接口接收数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">	SOCKET s,<span class="comment">//接收套接口</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> *buf,<span class="comment">//接收数据的缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> len,<span class="comment">//缓冲区中数据的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> flags<span class="comment">//调用方式标志位,一般取0</span></span></span></span><br><span class="line"><span class="function"><span class="params">	struct sockaddr FAR *from, <span class="comment">//获取发送套接口的主机地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> fromlen<span class="comment">//发送套接口的主机地址的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>主要用于无连接类型套接口向to参数指定端的套接口发送数据报。对于<br>SOCK_STREAM类型套接口,to和tolen参数被忽略;这种情况下sendto()等价于<br>send()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int recv(//从一个套接口接收数据</span><br><span class="line">	SOCKET s,//接收套接口</span><br><span class="line">	char *buf,/接收数据的缓冲区</span><br><span class="line">	int len,///缓冲区中数据的长度</span><br><span class="line">	int flags//调用方式标志位,一般取0</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="close-函数与shutdown-函数"><a href="#close-函数与shutdown-函数" class="headerlink" title="close()函数与shutdown()函数"></a>close()函数与shutdown()函数</h2><p>从TCP协议角度来看，一个已建立的TCP连接有两种关闭方式，一种是正常关闭，即四次挥手关闭连接；还有一种则是异常关闭，我们通常称之为连接重置(RESET)。<br>首先说一下正常关闭时四次挥手的状态变迁，关闭连接的主动方状态变迁是FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT，而关闭连接的被对方的状态变迁是CLOSE_WAIT-&gt;LAST_ACK-&gt;TIME_WAIT。在四次挥手过程中ACK包都是协议栈自动完成的，而FIN包则必须由应用层通过closesocket或shutdown主动发送，通常连接正常关闭后，recv会得到返回值0，send会得到错误码10058。<br>一个文件描述符关联着一个实际的文件——不管这个文件是什么，普通文件或网络套接口等等，但是多个打字可以同时与一个文件关联，并且内核维护一个文件引用计数。正常情况下，close函数不武断地释放一个描述字关联的文件，除了这个引用计数为0的时候，并且无论如何，当对一个描述字调用了close函数，用户无法再次使用这个描述字。这是close相对shutdown的两点差别，相应地shutdown是针对socket套接口定制的函数，所以它会做的更好。</p>
<p>shutdown函数不是参考引用计数，它会直接关闭相应的socket套接口，无论引用计数是多少。我们还知道，socket套接口是全双工的，也就是用户可以读，也可以写。存在一个这样的情况，此时用户已经把所有要写的数据都写完了，他想告诉对等端这一点；或者用户把所有要读的数据都读完成了，同样要告诉对等端。此时就是关闭读这一半或写这一半，使用shutdown可以完成这一个。系统定义了3个宏，这3个宏分别用作shutdown的后一个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHUT_RD：关闭读这一半，此时用户不能再从这个套接字读数据，这个套接口接收到的数据都会被丢弃，对等方不知道这个过程。</span><br><span class="line">SHUT_WR：相应地关闭写这一半，此时用户不能再向套接字中写数据，内核会把缓存中的数据发送出去，接着不会再发送数据，对等端将会知道这一点。当对等端试图去读的时候，可能会发生错误。</span><br><span class="line">SHUT_RDWR：关闭读与写两半，此时用户不能从套接字中读或写。它相当于再次调用shutdown函数，并且一次指定SHUT_RD，一次指定SHUT_WR。</span><br></pre></td></tr></table></figure></p>
<h1 id="无连接协议的同步模式"><a href="#无连接协议的同步模式" class="headerlink" title="无连接协议的同步模式"></a>无连接协议的同步模式</h1><p>无连接服务器一般都是面向事务处理的。一个请求一个应答就完成了客户程序与服务程序之间的相互作用。<br><img src="/images/socket_udp.png" alt=""><br>服务器首先启动,通过调用socket()建立一个套接口,<br>然后bind()将该套接口和本地地址(IP地址和端口)联系在一起,<br>服务器调用recv()等待接收数据。</p>
<p>客户机通过调用socket()建立一个套接口,<br>然后bind()将该套接口和本地地址(IP地址和端口)联系在一起,<br>客户机调用sendto()向服务器发送数据;</p>
<p>服务器的recv()接收到客户机的数据后,<br>调用sendto()向客户机发送应答数据;</p>
<p>客户机的recv()便接收到了服务器的应答数据;</p>
<p>最后,待数据传送结束后,双方调用closesocket()关闭套接口。</p>
<h1 id="有连接协议"><a href="#有连接协议" class="headerlink" title="有连接协议"></a>有连接协议</h1><p><img src="/images/Socket.jpg" alt=""><br>      服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>

          
            <a href="https://www.patreon.com/arsnippet" target="_blank"><img src="/img/patreon.png" alt="support my work at patron"> <a href="https://discord.gg/CB6CPzq" target="_blank"><img src="/img/discord.png" alt="Join the Discord"></a> <br><br><a href="https://arsnippet.freeflarum.com/" target="_blank"><img src="/img/forum.jpg" alt="support my work at patron"></a>
          
          <hr>
          <ul class="pager">
              
              <li class="previous">
                  <a href="/nc命令使用方法/" data-toggle="tooltip" data-placement="left"
                     title="nc命令使用方法">&larr; Previous Post</a>
              </li>
              
              
              <li class="next">
                  <a href="/iptables/" data-toggle="tooltip" data-placement="top"
                     title="iptables">Next Post&rarr;</a>
              </li>
              
          </ul>
        
  <br>
  
  <!-- disqus start -->
  <div class="comment">
    <div id="disqus_thread"  class="disqus-thread"></div>
      <script>
      var disqus_shortname = 'hexo-a-rsnippet';
      
      var disqus_url = 'http://yoursite.com/Socket编程/';
      
      (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  <!-- disqus end -->
  

  
  </div>


        
  <div class="hidden-xs col-sm-3 toc-col">
    <div class="toc-wrap">
        Table of Contents
        
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Socket类型"><span class="toc-number">1.</span> <span class="toc-text">Socket类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream-Socket"><span class="toc-number">1.1.</span> <span class="toc-text">Stream Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Datagram-Socket"><span class="toc-number">1.2.</span> <span class="toc-text">Datagram Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Raw-Socket"><span class="toc-number">1.3.</span> <span class="toc-text">Raw Socket</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Socket接口函数"><span class="toc-number">2.</span> <span class="toc-text">Socket接口函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#socket-函数"><span class="toc-number">2.1.</span> <span class="toc-text">socket()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind-函数"><span class="toc-number">2.2.</span> <span class="toc-text">bind()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主机地址标识"><span class="toc-number">2.2.1.</span> <span class="toc-text">主机地址标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主机地址标识的数据结构"><span class="toc-number">2.2.2.</span> <span class="toc-text">主机地址标识的数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#listen-函数"><span class="toc-number">2.3.</span> <span class="toc-text">listen()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#connect-函数"><span class="toc-number">2.4.</span> <span class="toc-text">connect()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#accept-函数"><span class="toc-number">2.5.</span> <span class="toc-text">accept()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#listen、connect、accept流程及三次握手"><span class="toc-number">2.6.</span> <span class="toc-text">listen、connect、accept流程及三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#send-recv和sendto-recvfrom"><span class="toc-number">2.7.</span> <span class="toc-text">send/recv和sendto/recvfrom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#close-函数与shutdown-函数"><span class="toc-number">2.8.</span> <span class="toc-text">close()函数与shutdown()函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#无连接协议的同步模式"><span class="toc-number">3.</span> <span class="toc-text">无连接协议的同步模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#有连接协议"><span class="toc-number">4.</span> <span class="toc-text">有连接协议</span></a></li></ol>
        
    </div>
  </div>


      </div>
  </div>
</article>

<!-- Footer -->
<!-- footer.ejs -->
<footer>
    <div class="text-center">
      <ul class="list-inline">
          
              <li>
                  <a href="/atom.xml" target="_blank">
                      <span class="fa-stack fa-lg">
                          <i class="fa fa-circle fa-stack-2x"></i>
                          <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                      </span>
                  </a>
              </li>
          
          
          

          
              <li>
                  <a target="_blank" href="http://weibo.com/u/2911633817">
                      <span class="fa-stack fa-lg">
                          <i class="fa fa-circle fa-stack-2x"></i>
                          <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                      </span>
                  </a>
              </li>
          

          

          
              <li>
                  <a target="_blank"  href="https://github.com/asensioatgithub">
                      <span class="fa-stack fa-lg">
                          <i class="fa fa-circle fa-stack-2x"></i>
                          <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                      </span>
                  </a>
              </li>
          

          

          
              <li>
                  <a href="mailto:emilsinclair@163.com" target="_blank">
                      <span class="fa-stack fa-lg">
                          <i class="fa fa-circle fa-stack-2x"></i>
                          <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                      </span>
                  </a>
              </li>
          

      </ul>
     <div class="text-muted copyright">
            &copy;
            
            2017 - 2018
            
            
              <i class="fa fa-heart"></i>
            
            Asensio
        <br>
          
              Powered by <a target="_blank" href="https://hexo.io">Hexo</a>
          
          
            |
          
          
              Theme - <a href="https://github.com/huyingjie/hexo-theme-A-RSnippet" target="_blank">A-RSnippet</a> v0.1.0
          
          
      </div>
    </div>
</footer>

<!-- Custom Theme JavaScript -->
<script src="/js/main.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



</body>

</html>
